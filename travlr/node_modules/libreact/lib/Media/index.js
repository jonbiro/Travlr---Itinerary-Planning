"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var util_1 = require("../util");
var parseTimeRanges_1 = tslib_1.__importDefault(require("./parseTimeRanges"));
var defaultState = {
    buffered: [],
    time: 0,
    duration: 0,
    isPlaying: false,
    muted: false,
    volume: 1,
    canPlay: false,
};
var Media = (function (_super) {
    tslib_1.__extends(Media, _super);
    function Media() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tag = 'video';
        _this.el = null;
        _this.state = defaultState;
        _this.ref = function (el) {
            _this.el = el;
        };
        _this.lockPlay = false;
        _this.play = function () {
            if (_this.el && !_this.lockPlay) {
                var promise = _this.el.play();
                var isPromise = typeof promise === 'object';
                if (isPromise) {
                    _this.lockPlay = true;
                    var resetLock = function () {
                        _this.lockPlay = false;
                    };
                    promise.then(resetLock, resetLock);
                }
            }
        };
        _this.pause = function () {
            if (_this.el && !_this.lockPlay) {
                _this.el.pause();
            }
        };
        _this.seek = function (time) {
            if (_this.el) {
                time = Math.min(_this.state.duration, Math.max(0, time));
                _this.el.currentTime = time;
            }
        };
        _this.volume = function (volume) {
            if (_this.el) {
                volume = Math.min(1, Math.max(0, volume));
                _this.el.volume = volume;
                _this.setState({
                    volume: volume
                });
            }
        };
        _this.mute = function () {
            if (_this.el) {
                _this.el.muted = true;
            }
        };
        _this.unmute = function () {
            if (_this.el) {
                _this.el.muted = false;
            }
        };
        _this.event = function (name) { return function (event) {
            var handler = _this.props[name];
            if (handler) {
                handler(event, _this, _this.state);
            }
        }; };
        _this.onPlay = function (event) {
            _this.change({
                isPlaying: true
            });
            _this.event('onPlay')(event);
        };
        _this.onPause = function (event) {
            _this.change({
                isPlaying: false
            });
            _this.event('onPause')(event);
        };
        _this.onVolumeChange = function (event) {
            var _a = _this.el, muted = _a.muted, volume = _a.volume;
            _this.change({
                muted: muted,
                volume: volume
            });
            _this.event('onVolumeChange')(event);
        };
        _this.onDurationChange = function (event) {
            var _a = _this.el, duration = _a.duration, buffered = _a.buffered;
            _this.change({
                duration: duration,
                buffered: parseTimeRanges_1.default(buffered)
            });
            _this.event('onDurationChange')(event);
        };
        _this.onTimeUpdate = function (event) {
            _this.change({
                time: _this.el.currentTime
            });
            _this.event('onTimeUpdate')(event);
        };
        _this.onProgress = function (event) {
            _this.change({
                buffered: parseTimeRanges_1.default(_this.el.buffered)
            });
            _this.event('onProgress')(event);
        };
        _this.onCanPlay = function (event) {
            _this.change({
                canPlay: true,
            });
            _this.event('onCanPlay')(event);
        };
        return _this;
    }
    Media.prototype.componentDidMount = function () {
        this.setState({
            volume: this.el.volume,
            muted: this.el.muted,
        });
        this.event('onMount')(this);
        if (this.props.autoPlay && this.el.paused) {
            this.play();
        }
    };
    Media.prototype.componentWillUnmount = function () {
        this.el = null;
        this.event('onUnmount')(this);
    };
    Media.prototype.componentDidUpdate = function (prevProps) {
        if (prevProps.src !== this.props.src) {
            this.setState(defaultState);
        }
    };
    Media.prototype.change = function (nextState) {
        var _this = this;
        this.setState(nextState, function () {
            _this.event('onChange')(null);
        });
    };
    Media.prototype.render = function () {
        var _a = this, props = _a.props, event = _a.event;
        var _b = props, _c = _b.tag, tag = _c === void 0 ? this.tag : _c, children = _b.children, render = _b.render, noJs = _b.noJs, onMount = _b.onMount, onUnmount = _b.onUnmount, rest = tslib_1.__rest(_b, ["tag", "children", "render", "noJs", "onMount", "onUnmount"]);
        return util_1.h(tag, tslib_1.__assign({ controls: false }, rest, { ref: this.ref, onAbort: event('onAbort'), onCanPlay: this.onCanPlay, onCanPlayThrough: event('onCanPlayThrough'), onDurationChange: this.onDurationChange, onEmptied: event('onEmptied'), onEncrypted: event('onEncrypted'), onEnded: event('onEnded'), onError: event('onError'), onLoadedData: event('onLoadedData'), onLoadedMetadata: event('onLoadedMetadata'), onLoadStart: event('onLoadStart'), onPause: this.onPause, onPlay: this.onPlay, onPlaying: event('onPlaying'), onProgress: this.onProgress, onRateChange: event('onRateChange'), onSeeked: event('onSeeked'), onSeeking: event('onSeeking'), onStalled: event('onStalled'), onSuspend: event('onSuspend'), onTimeUpdate: this.onTimeUpdate, onVolumeChange: this.onVolumeChange, onWaiting: event('onWaiting') }), noJs);
    };
    return Media;
}(React.Component));
exports.Media = Media;
//# sourceMappingURL=index.js.map