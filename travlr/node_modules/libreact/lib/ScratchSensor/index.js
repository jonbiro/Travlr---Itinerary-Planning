"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = require("react");
var util_1 = require("../util");
var react_universal_interface_1 = require("react-universal-interface");
var ScratchSensor = (function (_super) {
    tslib_1.__extends(ScratchSensor, _super);
    function ScratchSensor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isScratching: false,
        };
        _this.el = null;
        _this.frame = null;
        _this.ref = function (originalRef) { return function (el) {
            _this.el = el;
            (originalRef || util_1.noop)(el);
        }; };
        _this.onMouseDown = function (originalMouseDown) { return function (event) {
            (originalMouseDown || util_1.noop)(event);
            _this.startScratching(event.pageX, event.pageY);
        }; };
        _this.onTouchStart = function (originalTouchStart) { return function (event) {
            (originalTouchStart || util_1.noop)(event);
            _this.startScratching(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
        }; };
        _this.stopScratching = function () {
            if (_this.state.isScratching) {
                _this.setState({ isScratching: false });
                _this.props.onScratchEnd(tslib_1.__assign({}, _this.state, { isScratching: false }));
                _this.unbindEvents();
            }
        };
        _this.onMouseMove = function (event) {
            _this.onMoveEvent(event.pageX, event.pageY);
        };
        _this.onTouchMove = function (event) {
            _this.onMoveEvent(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
        };
        _this.onMouseUp = _this.stopScratching;
        _this.onTouchEnd = _this.stopScratching;
        _this.onMoveEvent = function (docX, docY) {
            var el = _this.el;
            if (!el) {
                return;
            }
            cancelAnimationFrame(_this.frame);
            _this.frame = requestAnimationFrame(function () {
                var _a = el.getBoundingClientRect(), left = _a.left, top = _a.top;
                var elX = left + window.scrollX;
                var elY = top + window.scrollY;
                var x = docX - elX;
                var y = docY - elY;
                _this.setState({
                    dx: x - _this.state.x,
                    dy: y - _this.state.y,
                    end: Date.now(),
                }, function () {
                    _this.props.onScratch(_this.state);
                });
            });
        };
        return _this;
    }
    ScratchSensor.prototype.componentWillUnmount = function () {
        this.unbindEvents();
    };
    ScratchSensor.prototype.startScratching = function (docX, docY) {
        if (this.state.isScratching) {
            return;
        }
        var el = this.el;
        if (!el) {
            return;
        }
        var _a = el.getBoundingClientRect(), left = _a.left, top = _a.top;
        var elX = left + window.scrollX;
        var elY = top + window.scrollY;
        var x = docX - elX;
        var y = docY - elY;
        var time = Date.now();
        var newState = {
            isScratching: true,
            start: time,
            end: time,
            docX: docX,
            docY: docY,
            x: x,
            y: y,
            dx: 0,
            dy: 0,
            elH: el.offsetHeight,
            elW: el.offsetWidth,
            elX: elX,
            elY: elY,
        };
        this.props.onScratchStart(newState);
        this.setState(newState);
        this.bindEvents();
    };
    ScratchSensor.prototype.bindEvents = function () {
        util_1.on(document, 'mousemove', this.onMouseMove);
        util_1.on(document, 'mouseup', this.onMouseUp);
        util_1.on(document, 'touchmove', this.onTouchMove);
        util_1.on(document, 'touchend', this.onTouchEnd);
    };
    ScratchSensor.prototype.unbindEvents = function () {
        util_1.off(document, 'mousemove', this.onMouseMove);
        util_1.off(document, 'mouseup', this.onMouseUp);
        util_1.off(document, 'touchmove', this.onTouchMove);
        util_1.off(document, 'touchend', this.onTouchEnd);
    };
    ScratchSensor.prototype.render = function () {
        var _a = this.props, disabled = _a.disabled, bond = _a.bond;
        if (bond) {
            var bondName = typeof bond === 'string' ? bond : 'bond';
            var state = tslib_1.__assign({}, this.state);
            if (!disabled) {
                state[bondName] = {
                    ref: this.ref(),
                    onMouseDown: this.onMouseDown(),
                    onTouchStart: this.onTouchStart(),
                };
            }
            return react_universal_interface_1.render(this.props, state);
        }
        else {
            var element = react_universal_interface_1.render(this.props, this.state);
            if (!disabled) {
                element = react_1.cloneElement(element, {
                    ref: this.ref(element.ref),
                    onMouseDown: this.onMouseDown(element.props.onMouseDown),
                    onTouchStart: this.onTouchStart(element.props.onTouchStart),
                });
            }
            return element;
        }
    };
    ScratchSensor.defaultProps = {
        disabled: false,
        onScratch: util_1.noop,
        onScratchStart: util_1.noop,
        onScratchEnd: util_1.noop,
    };
    return ScratchSensor;
}(react_1.Component));
exports.ScratchSensor = ScratchSensor;
exports.withScratch = react_universal_interface_1.createEnhancer(ScratchSensor, 'scratch');
//# sourceMappingURL=index.js.map