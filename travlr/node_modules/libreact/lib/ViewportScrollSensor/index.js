"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var util_1 = require("../util");
var throttle_debounce_1 = require("throttle-debounce");
var renderProp_1 = tslib_1.__importDefault(require("../util/renderProp"));
exports.getElRect = function (el) {
    var _a = el.getBoundingClientRect(), top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;
    return [left, top, right, bottom];
};
exports.getRootRect = function (_a) {
    var top = _a[0], right = _a[1], bottom = _a[2], left = _a[3];
    return [
        0 - left,
        0 - top,
        (window.innerWidth || document.documentElement.clientWidth) + right,
        (window.innerHeight || document.documentElement.clientHeight) + bottom,
    ];
};
var intersect = function (rect1, rect2) {
    var x1 = rect1[0], y1 = rect1[1], x2 = rect1[2], y2 = rect1[3];
    var x3 = rect2[0], y3 = rect2[1], x4 = rect2[2], y4 = rect2[3];
    var x5 = Math.max(x1, x3);
    var x6 = Math.min(x2, x4);
    var y5 = Math.max(y1, y3);
    var y6 = Math.min(y2, y4);
    if ((x5 >= x6) || (y5 >= y6)) {
        return null;
    }
    return [x5, y5, x6, y6];
};
var area = function (_a) {
    var x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];
    return (x2 - x1) * (y2 - y1);
};
var ViewportScrollSensor = (function (_super) {
    tslib_1.__extends(ViewportScrollSensor, _super);
    function ViewportScrollSensor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.mounted = false;
        _this.state = {
            visible: false
        };
        _this.ref = function (originalRef) { return function (el) {
            _this.el = el;
            (originalRef || util_1.noop)(el);
        }; };
        _this.poll = function () {
            if (_this.mounted) {
                _this.onScroll();
                setTimeout(_this.poll, _this.props.poll);
            }
        };
        _this.onScroll = throttle_debounce_1.throttle(_this.props.throttle, false, function () {
            if (!_this.mounted) {
                return;
            }
            var _a = _this.props, threshold = _a.threshold, margin = _a.margin;
            var visible = false;
            var rectRoot = exports.getRootRect(margin);
            var rectEl = exports.getElRect(_this.el);
            var rectIntersection = intersect(rectEl, rectRoot);
            if (rectIntersection) {
                var areaEl = area(rectEl);
                var areaIntersection = area(rectIntersection);
                var intersectionRatio = areaIntersection / areaEl;
                visible = !!((!threshold && intersectionRatio) || (intersectionRatio >= threshold));
            }
            _this.onCalculation(visible, rectRoot, rectEl, rectIntersection);
        });
        return _this;
    }
    ViewportScrollSensor.prototype.componentDidMount = function () {
        this.mounted = true;
        util_1.on(document, 'scroll', this.onScroll);
        util_1.on(window, 'resize', this.onScroll);
        this.onScroll();
        if (this.props.poll) {
            setTimeout(this.poll, this.props.poll);
        }
    };
    ViewportScrollSensor.prototype.componentWillUnmount = function () {
        this.mounted = false;
        clearTimeout(this.pollTimer);
        util_1.off(document, 'scroll', this.onScroll);
        util_1.off(window, 'resize', this.onScroll);
    };
    ViewportScrollSensor.prototype.onCalculation = function (visible, rectRoot, rectEl, rectIntersection) {
        if (visible !== this.state.visible) {
            var state = {
                visible: visible
            };
            this.setState(state);
            (this.props.onChange || util_1.noop)(state);
        }
    };
    ViewportScrollSensor.prototype.render = function () {
        var element = renderProp_1.default(this.props, this.state);
        if (process.env.NODE_ENV !== 'production') {
            if ((typeof element !== 'object') || (typeof element.type !== 'string')) {
                throw new TypeError('<ViewportScrollSensor> accepts a single child which must be ' +
                    'a plain DOM element or a function that returns one.');
            }
        }
        return React.cloneElement(element, {
            ref: this.ref(element.ref)
        });
    };
    ViewportScrollSensor.defaultProps = {
        threshold: 0,
        throttle: 50,
        margin: [0, 0, 0, 0]
    };
    return ViewportScrollSensor;
}(React.Component));
exports.ViewportScrollSensor = ViewportScrollSensor;
//# sourceMappingURL=index.js.map