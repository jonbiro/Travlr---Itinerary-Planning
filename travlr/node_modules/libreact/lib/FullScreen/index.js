"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = require("react");
var util_1 = require("../util");
var screenfull = require('screenfull');
var FullScreen = (function (_super) {
    tslib_1.__extends(FullScreen, _super);
    function FullScreen() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.el = null;
        _this.mounted = false;
        _this.ref = function (el) {
            _this.el = el;
            _this.props.innerRef(el);
        };
        _this.onChange = function () {
            var isFullScreen = screenfull.element === _this.el;
            if (!isFullScreen) {
                (_this.props.onClose || util_1.noop)();
            }
        };
        return _this;
    }
    FullScreen.prototype.componentDidMount = function () {
        this.mounted = true;
        screenfull.on('change', this.onChange);
    };
    FullScreen.prototype.componentDidUpdate = function (props) {
        if (!props.on && this.props.on) {
            this.enter();
        }
        else if (props.on && !this.props.on) {
            this.leave();
        }
    };
    FullScreen.prototype.componentWillUnmount = function () {
        this.mounted = false;
        screenfull.off('change', this.onChange);
    };
    FullScreen.prototype.enter = function () {
        var _this = this;
        if (this.el) {
            if (screenfull.enabled) {
                try {
                    screenfull.request(this.el);
                }
                catch (_a) { }
            }
            else {
                var video_1 = this.props.video;
                if (video_1 && video_1.webkitEnterFullscreen) {
                    var onWebkitEndFullscreen_1 = function () {
                        video_1.removeEventListener('webkitendfullscreen', onWebkitEndFullscreen_1);
                        if (_this.mounted) {
                            _this.props.onClose();
                        }
                    };
                    video_1.webkitEnterFullscreen();
                    video_1.addEventListener('webkitendfullscreen', onWebkitEndFullscreen_1);
                }
            }
        }
    };
    FullScreen.prototype.leave = function () {
        if (screenfull.enabled) {
            try {
                screenfull.exit();
            }
            catch (_a) { }
        }
        else {
            var video = this.props.video;
            if (video && video.webkitExitFullscreen) {
                video.webkitExitFullscreen();
            }
        }
    };
    FullScreen.prototype.render = function () {
        var _a = this.props, video = _a.video, innerRef = _a.innerRef, on = _a.on, onClose = _a.onClose, tag = _a.tag, children = _a.children, rest = tslib_1.__rest(_a, ["video", "innerRef", "on", "onClose", "tag", "children"]);
        rest.ref = this.ref;
        return util_1.h.apply(void 0, [tag, rest].concat(react_1.Children.toArray(children)));
    };
    FullScreen.defaultProps = {
        onClose: util_1.noop,
        innerRef: util_1.noop,
        tag: 'div'
    };
    return FullScreen;
}(react_1.Component));
exports.FullScreen = FullScreen;
//# sourceMappingURL=index.js.map