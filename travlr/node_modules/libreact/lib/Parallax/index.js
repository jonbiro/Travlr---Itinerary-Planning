"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var react_universal_interface_1 = require("react-universal-interface");
var util_1 = require("../util");
var ViewportScrollSensor_1 = require("../ViewportScrollSensor");
var throttle_debounce_1 = require("throttle-debounce");
var zeros = [0, 0, 0, 0];
var Parallax = (function (_super) {
    tslib_1.__extends(Parallax, _super);
    function Parallax(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.mounted = false;
        _this.ref = function (originalRef) { return function (el) {
            _this.el = el;
            (originalRef || util_1.noop)(el);
        }; };
        _this.onScroll = throttle_debounce_1.throttle(_this.props.throttle, false, function () {
            if (!_this.mounted) {
                return;
            }
            var margin = _this.props.margin;
            var el = ViewportScrollSensor_1.getElRect(_this.el);
            var root = ViewportScrollSensor_1.getRootRect(margin);
            var rootHeight = root[3] - root[1];
            var elHeight = el[3] - el[1];
            var distance = Math.min(rootHeight + elHeight, _this.props.distance);
            var travelled = root[3] - el[1];
            var value = Math.max(0, Math.min(1, travelled / distance));
            if (value > 0 && value < 1) {
                _this.change({ distance: distance, travelled: travelled, value: value, el: el, root: root });
            }
            else {
                if (_this.state.value > 0 && _this.state.value < 1) {
                    _this.change({ distance: distance, travelled: travelled, value: value, el: el, root: root });
                }
            }
        });
        _this.state = {
            distance: _this.props.distance,
            travelled: 0,
            value: 0,
            el: zeros,
            root: zeros,
        };
        return _this;
    }
    Parallax.prototype.componentDidMount = function () {
        this.mounted = true;
        util_1.on(document, 'scroll', this.onScroll);
        this.onScroll();
    };
    Parallax.prototype.componentWillUnmount = function () {
        this.mounted = false;
        util_1.off(document, 'scroll', this.onScroll);
    };
    Parallax.prototype.change = function (newState) {
        this.setState(newState);
        (this.props.onChange || util_1.noop)(newState);
    };
    Parallax.prototype.render = function () {
        var element = react_universal_interface_1.render(this.props, this.state);
        if (process.env.NODE_ENV !== 'production') {
            if ((typeof element !== 'object') || (typeof element.type !== 'string')) {
                throw new TypeError('<Parallax> accepts a single child which must be ' +
                    'a plain DOM element or a function that returns one.');
            }
        }
        return React.cloneElement(element, {
            ref: this.ref(element.ref)
        });
    };
    Parallax.defaultProps = {
        distance: Infinity,
        margin: zeros,
        throttle: 50,
    };
    return Parallax;
}(React.Component));
exports.Parallax = Parallax;
//# sourceMappingURL=index.js.map