// Preventing the Google Maps libary from downloading an extra font
export var preventGoogleFonts = function () {
    var isRobotoStyle = function (element) {
        // roboto font download
        if (element.href &&
            element.href.indexOf('https://fonts.googleapis.com/css?family=Roboto') === 0) {
            return true;
        }
        // roboto style elements
        if (element.tagName.toLowerCase() === 'style' &&
            element.styleSheet &&
            element.styleSheet.cssText &&
            element.styleSheet.cssText.replace('\r\n', '').indexOf('.gm-style') === 0) {
            element.styleSheet.cssText = '';
            return true;
        }
        // roboto style elements for other browsers
        if (element.tagName.toLowerCase() === 'style' &&
            element.innerHTML &&
            element.innerHTML.replace('\r\n', '').indexOf('.gm-style') === 0) {
            element.innerHTML = '';
            return true;
        }
        // when google tries to add empty style
        if (element.tagName.toLowerCase() === 'style' && !element.styleSheet && !element.innerHTML) {
            return true;
        }
        return false;
    };
    // we override these methods only for one particular head element
    // default methods for other elements are not affected
    var head = document.getElementsByTagName('head')[0];
    var insertBefore = head.insertBefore;
    // TODO: adding return before reflect solves the TS issue
    //@ts-ignore
    head.insertBefore = function (newElement, referenceElement) {
        if (!isRobotoStyle(newElement)) {
            Reflect.apply(insertBefore, head, [newElement, referenceElement]);
        }
    };
    var appendChild = head.appendChild;
    // TODO: adding return before reflect solves the TS issue
    //@ts-ignore
    head.appendChild = function (textNode) {
        if (!isRobotoStyle(textNode)) {
            Reflect.apply(appendChild, head, [textNode]);
        }
    };
};
//# sourceMappingURL=prevent-google-fonts.js.map